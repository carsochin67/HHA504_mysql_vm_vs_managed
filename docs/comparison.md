Working through this database connectivity assignment was ultimately productive, even though the two environments behaved very differently. The VM-based MySQL database made the most sense to me and ended up being the part I understood the best. Because everything was running locally on the Compute Engine VM, I could directly control the MySQL service, open ports, adjust configuration files, and verify that the database was actually listening. Once the firewall and bind-address were set correctly, the connection from my Python script worked smoothly. It felt logical and hands-on, and I could clearly see how changes on the server affected the behavior of my client application.

The Google Cloud SQL managed database, however, was much more confusing. Even though I configured the public IP, authorized networks, and environment variables correctly, I kept running into connectivity timeouts. It wasn’t clear whether the issue came from my local network, the Cloud SQL networking layer, firewall rules behind the scenes, or something else entirely. I understand that Cloud SQL is supposed to simplify database administration, but in this case, the abstraction made it harder to diagnose what was actually happening. I’m still not sure why the GCP database never connected, but I learned a lot about how cloud networking, ports, and database services interact—even when things don’t work the way you expect.